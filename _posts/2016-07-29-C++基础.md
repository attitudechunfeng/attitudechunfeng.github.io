---
layout:     post
title:      "C++基础"
subtitle:   "C++基础面试要点"
date:       2016-07-29
author:     "attitudechunfeng"
header-img: "img/home-bg.jpg"
---

### 					C++基础面试要点总结

------

##### [1] 多继承（菱形继承的）的弊端，c++如何解决？（百度）

答：会产生二义性，最下方的派生类继承了多个类的实体，通过虚基类的方法解决。虚拟继承的开销是增加虚函数指针。

------

##### [2] 简述C++的多态机制。（百度）

答：多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。C++中的多态有着广泛的含义。除了常见的通过类继续和虚函数机制生效于运行期的动态多态（dynamic polymorphism）外，模板也答应将不同的非凡行为和单个泛化记号相关联，由于这种关联处理于编译期而非运行期，因此被称为静态多态（static polymorphism）。函数重载也是静态多态。

------

##### [3] 区分覆盖、隐藏、重载。

答： 

- 成员函数被重载的特征：

     （1）相同的范围（在同一个类中）；

     （2）函数名字相同；

     （3）参数不同；

     （4）virtual关键字可有可无。 

- 覆盖是指派生类函数覆盖基类函数，特征是：

     （1）不同的范围（分别位于派生类与基类）；

     （2）函数名字相同；

     （3）参数相同；

     （4）基类函数必须有virtual关键字。

- 隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：

     （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。

     （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

------

##### [4] 里氏代换原则：是继承复用的基石，子类型必须能够替换它们的基类型。

------

##### [5] 开闭原则：是面向对象设计的重要特性之一，软件对扩展应该是开放的，对修改应该是关闭的。

------

##### [6] 对于空类，编译器默认产生4个成员函数：默认构造函数、析构函数、复制构造函数和赋值函数。

------

##### [7] C++中struct和class的唯一区别是struct默认访问控制权限为public，而class为private。

------

##### [8] C++类中初始化列表的初始化变量顺序是根据成员变量的声明顺序来执行的。

------

##### [9] 析构函数如果不被设为虚函数，原因在于多态过程中易出现内存泄漏，基指针指向子类对象时，如果析构函数不是虚函数，则会调用基类析构函数，此时如果子类中申请了堆上的内存，就会出现内存泄漏。如果将析构函数设为虚函数，则会从子类到基类顺序调用析构函数。

------

##### [10] 构造函数为什么不能为虚？

答：虚函数采用一种虚调用的方法，这是一种可以在只有部分信息的情况下工作的机制，允许我们调用一个只知道结构而不知道其准确对象类型的函数。但是如果想要创建对象，就必须要知道对象的准确类型，因此构造函数不能为虚。

------

##### [11] 析构函数可以是内联函数。

------

##### [12] 派生类中的虚函数可以返回基类函数所返回类型的派生类的引用或指针。

------

##### [13] C++中不应该从析构函数中抛出异常。

------

##### [14] 含有纯虚函数的类称为抽象类，抽象类不能实例化对象。

------

##### [15] C++中如何阻止一个类被实例化？

答：使用抽象类，或者构造函数声明为private。

------

[16] C++四种类型转换方式。

- static_cast:最常用的类型转换符，在正常状况下的类型转换，如把int转换为float。是用static_cast好处是，可以一眼看出来这里有强制转换。出现证明程序不合理，需要修改。

- const_cast:用于取出const属性，把const类型的指针变为非const类型的指针。

- dynamic_cast:该操作符用于运行时检查该转换是否类型安全，但只在多态类型时合法，即该类至少具有一个虚拟方法。dynamic_cast与static_cast具有相同的基本语法，dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

- reinterpret_cast:此标识符的意思即为数据的二进制形式重新解释，但是不改变其值，这个转换方式很少使用。

------

[17] <u>子类对象的引用和指针可以转换为父类对象的引用和指针。</u>***但是，严格来说子类对象不可以转换为父类对象，然而，确实可以在需要一个父类对象的地方使用子类对象，<u>这种是借助于子类对象引用与父类对象引用的转换 以及 父类对象的copy构造函数实现的。</u>
例如：Base 为父类，B1 是其子类。
B1   b;
Base a(b); 这句话中就好像将子类对象b 转换为一个 父类的临时对象，然后又用这个临时对象初始化对象a 。但是，是这样的吗？下面来仔细分析一下。这句话中调用的copy构造函数的原型是
Base：：Base（ const Base ＆base）；注意这个函数的参数是一个父类对象引用。首先将一个父类Base的引用base绑定到子类对象，然后将该引用作为实参传递给copy构造函数。copy构造函数使用 子类B1对象的父类部分，对a进行初始化。构造函数运行完毕，就产生了对象a。<u>从父类到派生类的自动转换是不存在的。</u>

------

[18] 

##### C++只能动态分配对象方法：

将类的构造函数和析构函数设为protected属性，这样类对象不能够访问，但是派生类能够访问，能够正常的继承。同时创建另外两个create和destory函数类创建对象。（将create设为static原因是：创建对象的时候是A *p = A::create(); 只有静态成员函数才能够通过类名来访问。）

##### C++只能静态分配对象方法:

把new、delete运算符重载为private属性就可以了。

------

##### [19] 模版特化的概念，为什么特化?

模板的特化是在已有的通用模板不再适用于一些特殊的类型参数时，而针对这些特殊的类型参数专门实现的模板。

------

##### [20] const意味着"只读"。const修饰的变量不能为赋值运算符左值，更多的传递信息，减少垃圾产生。

------

##### [21] 必须在构造函数初始化列表里初始化的变量有：如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

------

##### [22] auto_ptr简介：

- 因为auto_ptr析构的时候肯定会删除他所拥有的那个对象，所以我们就要注意了，一个萝卜一个坑，两个auto_ptr不能同时拥有同一个对象。

- 因为auto_ptr的析构函数中删除指针用的是delete,而不是delete [],所以我们不应该用auto_ptr来管理一个数组指针。

- 构造函数的explicit关键词有效阻止从一个“裸”指针隐式转换成auto_ptr类型。

- 一个auto_ptr被拷贝或被赋值后，　其已经失去对原对象的所有权，这个时候，对这个auto_ptr的提领(dereference)操作是不安全的。

- auto_ptr不具有值语义(value semantic), 所以auto_ptr不能被用在stl标准容器中。

------



